# lprp

lprp ('l'eft 'p'aren 'r'ight 'p'aren) is simple S-expression reader.

`Token::List` generated by lprp implemented only `car` and `cdr`. However,
`car` and `cdr` in lprp are different from the original ones. Since there is
 no concept of a symbol, simply return the top and the rest of the list.
 
 In other words, **lprp is not a true S-expression reader**.

 May be flexible? :)

I thought about implementing symbols such as `cons`, `eq`, `atom`, etc... but
I decided to treat them as simple strings.

The value held by enum `Token` can be retrieved by `geti`, `getf`, `gets`,
 and `getl`.

if you want to do more processing, you can do it with Rust.

```
use lprp::reader::read;

fn main() {
    let sexp = "(cons (cons 1 2.0) (cons -3 nil))".to_string();

    let result = read(&sexp).unwrap();

    assert_eq!(
        result,
        Token::List(vec![
                    Token::Str("cons".to_string()),
                    Token::List(vec![
                                Token::Str("cons".to_string()),
                                Token::Int(1),
                                Token::Float(2.0)
                    ]),
                    Token::List(vec![
                                Token::Str("cons".to_string()),
                                Token::Int(-3),
                                Token::Nil
                    ])
        ])
    );
}
```
